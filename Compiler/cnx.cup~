package appetizer.syntactic;

import java.io.InputStream;
import appetizer.ast.*;

action code {:
  static appetizer.symbol.Symbol symbol{String s} {
    return appetizer.symbol.Symbol.symbol{s};
  }
:};

parser code {:
  public void report_error{String message, Object info} {
    StringBuffer m = new StringBuffer{"\tParsing error"};
    if {info instanceof java_cup.runtime.Symbol} {
      java_cup.runtime.Symbol s = {java_cup.runtime.Symbol} info;

      if {s.left >= 0} {
        m.append{" in line " + {s.left +1 }};
        if {s.right >= 0} {
          m.append{", column " + {s.right + 1}};
        }
      }
    }
    m.append{" : " + message};
    System.err.println{m};
  }

  public Parser{InputStream inp} {
    this{new Yylex{inp}};
  }
:};

terminal      TYPEDEF,VOID,CHAR,INT,STRUCT,UNION,IF,ELSE,WHILE,FOR,CONTINUE,BREAK,RETURN,SIZEOF;
terminal      LPAREN,RPAREN,SEMICOLON,COMMA,ASSIGN,LBRACE,RBRACE,LBRACK,RBRACK,BITOR,INDEX,BITAND,LT,GT,PLUS,MINUS,ASTER,DIVIDE,MOD,BITNOT,NOT,DOT;
terminal      OR,AND,EQ,NE,LE,GE,SHL,SHR,INC,DEC,PTR,ELLIPSIS;
terminal      MULASS,DIVASS,MODASS,ADDASS,SUBASS,SHLASS,SHRASS,ANDASS,XORASS,ORASS;
terminal String STR;
terminal Char CHR;
terminal Integer	NUM;
terminal String		ID;

non terminal Cnx cnx1,cnx2,cnx3,cnx4,cnx5,cnx6,cnx7,cnx8,cnx9,cnx10,cnx11,cnx12,cnx13,cnx14,cnx15,cnx16,cnx17,cnx18,cnx19,cnx20,cnx21,cnx22;
non terminal Program  program;
non terminal Decl declaration,declarator;
non terminal Func function_definition;
non terminal Para parameters;
non terminal Decls declarators;
non terminal Init_Decls init_declarators;
non terminal Init_Decl  init_declarator;
non terminal Initializer  initializer;
non terminal Type type_specifier;
non terminal St_Un  struct_or_union;
non terminal Plain_Decl plain_declaration,plain_declarator;
non terminal State statement;
non terminal Expr_State expression_statement;
non terminal Com_State compound_statement;
non terminal Sele_State selection_statement;
non terminal Iter_State iteration_statement;
non terminal Jump_State jump_statement;
non terminal Expr expression;
non terminal Ass_State assignment_operator;
non terminal Ass_Expr assignment_expression;
non terminal Const_Expr constant_expression;
non terminal Log_Or_Expr logical_or_expression;
non terminal Log_And_Expr logical_and_expression;
non terminal Inc_Or_Expr inclusive_or_expression;
non terminal Exc_Or_Expr exclusive_or_expression;
non terminal And_Expr and_expression;
non terminal Eq_Expr equality_expression;
non terminal Eq_Op equality_operator;
non terminal Rela_Expr relational_expression;
non terminal Rela_Op relational_operator;
non terminal Sh_Expr shift_expression;
non terminal Sh_Op shift_operator;
non terminal Add_Expr additive_expression;
non terminal Add_Op additive_operator;
non terminal Multi_Expr multiplicative_expression;
non terminal Multi_Op multiplicative_operator;
non terminal Cast_Expr cast_expression;
non terminal Type_Name type_name;
non terminal Un_Expr unary_expression;
non terminal Un_Op unary_operator;
non terminal Postfix_Expr postfix_expression;
non terminal Postfix postfix;
non terminal Argu arguments;
non terminal Pri_Expr primary_expression;
non terminal Con constant;

precedence left COMMA;
precedence right ASSIGN,MULASS,DIVASS,MODASS,ADDASS,SUBASS,SHLASS,SHRASS,ANDASS,ORASS,XORASS;
precedence left OR;
precedence left AND;
precedence left BITOR;
precedence left INDEX;

start with program;

 program::= cnx22 | cnx22 program;

 cnx22::= declaration | function_definition;
 
 declaration::= TYPEDEF type_specifier declarators SEMICOLON
            | type_specifier init_declarators SEMICOLON
            | type_specifier SEMICOLON
            ;
 
 function_definition::= type_specifier plain_declarator LPAREN parameters RPAREN compound_statement
                    | type_specifier plain_declarator LPAREN RPAREN compound_statement;
 
 parameters::= plain_declaration cnx1 COMMA ELLIPSIS
           | plain_declaration cnx1
           ;

 cnx1::= COMMA plain_declaration cnx1 | epsilon;
 
 declarators::= declarator cnx2;

 cnx2::= COMMA declarator cnx2 | epsilon;
 
 init_declarators::= init_declarator cnx3
                 ;

 cnx3::= COMMA init_declarator cnx3 | epsilon;
 
 init_declarator::= declarator ASSIGN initializer
                | declarator;
 
 initializer::= assignment_expression
            | LBRACE initializer cnx16 RBRACE
            ;

 cnx16::=initializer cnx16 | epsilon;
 
 type_specifier::= VOID | CHAR | INT | ID
               | struct_or_union ID LBRACE plain_declaration cnx17 RBRACE
               | struct_or_union LBRACE plain_declaration cnx17 RBRACE
               | struct_or_union ID
               ;

 cnx17::=plain_declaration cnx17 | epsilon;
 
 struct_or_union::= STRUCT | UNION;
 
 plain_declaration::= type_specifier declarator cnx18;

 cnx18::=declarator cnx18 | epsilon;
 
 declarator::= plain_declarator LPAREN parameters RPAREN
           | plain_declarator LPAREN RPAREN
           | plain_declarator cnx4
           ;

 cnx4 ::= LBRACK constant_expression RBRACK cnx4 | epsilon;
 
 plain_declarator::= cnx20 ID
                 ;

 statement::= expression_statement
          | compound_statement
          | selection_statement
          | iteration_statement
          | jump_statement
          ;
 
 expression_statement::= expression SEMICOLON
                     | SEMICOLON;
 
 compound_statement::= LBRACE cnx18 cnx21 RBRACE
                   ;

 cnx21::=statement cnx21 | epsilon;
 
 selection_statement::= IF LPAREN expression RPAREN statement ELSE statement
                    | IF LPAREN expression RPAREN statement
                    ;
 
 iteration_statement::= WHILE LPAREN expression RPAREN statement
                    | FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement
                    | FOR LPAREN expression SEMICOLON expression SEMICOLON  RPAREN statement
                    | FOR LPAREN expression SEMICOLON  SEMICOLON expression RPAREN statement
                    | FOR LPAREN expression SEMICOLON  SEMICOLON  RPAREN statement
                    | FOR LPAREN  SEMICOLON expression SEMICOLON expression RPAREN statement
                    | FOR LPAREN  SEMICOLON expression SEMICOLON  RPAREN statement
                    | FOR LPAREN  SEMICOLON  SEMICOLON expression RPAREN statement
                    | FOR LPAREN  SEMICOLON  SEMICOLON  RPAREN statement
                    ;
 
 jump_statement::= CONTINUE SEMICOLON
               | BREAK SEMICOLON
               | RETURN expression SEMICOLON
               | RETURN SEMICOLON
               ;

 expression::= assignment_expression cnx5
           ;

 cnx5::= COMMA assignment_expression cnx5 | epsilon;
 
 assignment_expression::= logical_or_expression
                      | unary_expression assignment_operator assignment_expression
                      ;
 
 assignment_operator::= ASSIGN | MULASS | DIVASS | MODASS | ADDASS | SUBASS | SHLASS | SHRASS | ANDASS | XORASS | ORASS;
 
 constant_expression::= logical_or_expression;
 
 logical_or_expression::= logical_and_expression cnx6
                      ;

 cnx6::=OR logical_and_expression cnx6 | epsilon;
 
 logical_and_expression::= inclusive_or_expression cnx7
                       ;
 
 cnx7::=AND inclusive_or_expression cnx7 | epsilon;

 inclusive_or_expression::= exclusive_or_expression cnx8
                        ;

 cnx8::=BITOR exclusive_or_expression cnx8 | epsilon;
 
 exclusive_or_expression::= and_expression cnx9
                        ;

 cnx9::=INDEX and_expression cnx9 | epsilon;
 
 and_expression::= equality_expression cnx10
               ;

 cnx10::=BITAND equality_expression cnx10 | epsilon;
 
 equality_expression::= relational_expression cnx11
                    ;

 cnx11::=equality_operator relational_expression cnx11 | epsilon;
 
 equality_operator::= EQ | NE;
 
 relational_expression::= shift_expression cnx12
                      ;

 cnx12::=relational_operator shift_expression cnx12 | epsilon;
 
 relational_operator::= LT | GT | LE | GE;
 
 shift_expression::= additive_expression cnx13
                 ;

 cnx13::=shift_operator additive_expression cnx13 | epsilon;
 
 shift_operator::= SHL | SHR;
 
 additive_expression::= multiplicative_expression cnx14
                    ;

 cnx14::=additive_operator multiplicative_expression cnx14 | epsilon;
 
 additive_operator::= PLUS | MINUS;
 
 multiplicative_expression::= cast_expression cnx15
                          ;

 cnx15::=multiplicative_operator cast_expression cnx15| epsilon;
 
 multiplicative_operator::= ASTER | DIVIDE | MOD;
 
 cast_expression::= unary_expression
                | LPAREN type_name RPAREN cast_expression
                ;
 
 type_name::= type_specifier cnx20
          ;

 cnx20::=ASTER cnx20 | epsilon;
 
 unary_expression::= postfix_expression
                 | INC unary_expression
                 | DEC unary_expression
                 | unary_operator cast_expression
                 | SIZEOF unary_expression
                 | SIZEOF LPAREN type_name RPAREN
                 ;
 
 unary_operator::= BITAND | ASTER | PLUS | MINUS | BITNOT | NOT;
 
 postfix_expression::= primary_expression cnx19
                   ;

 cnx19::= postfix cnx19 | epsilon;
 
 postfix::= LBRACK expression RBRACK
        | LPAREN arguments RPAREN
        | DOT ID
        | PTR ID
        | INC
        | DEC
        ;
 
 arguments::= assignment_expression cnx5
          ;
 
 primary_expression::= ID
                   | constant
                   | STR
                   | LPAREN expression RPAREN
                   ;
 
 constant::= NUM
         | CHR
         ;

 epsilon::= ;