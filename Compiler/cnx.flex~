package appetizer.syntactic;

%%

%unicode
%line
%column
%cup
%implements Symbols

%{
	private boolean commentCount = false;

	private void err(String message) {
		System.out.println("Scanning error in line " + yyline + ", column " + yycolumn + ": " + message);
	}

	private java_cup.runtime.Symbol tok(int kind) {
		return new java_cup.runtime.Symbol(kind, yyline, yycolumn);
	}

	private java_cup.runtime.Symbol tok(int kind, Object value) {
		return new java_cup.runtime.Symbol(kind, yyline, yycolumn, value);
	}
%}

%eofval{
	{
		if (yystate() == YYCOMMENT) {
			err("Comment symbol do not match (EOF)!");
		}
		return tok(EOF, null);
	}
%eofval}

LineTerm = \n|\r|\r\n
Identifier = [a-zA-Z_$][a-zA-Z0-9_$]*
DecInteger = [0-9]+|0[xX][a-zA-Z0-9]+
Whitespace = {LineTerm}|[ \t\f]

%state	YYCOMMENT

%%

<YYINITIAL> {
	"/*" { commentCount = true; yybegin(YYCOMMENT); }
	"*/" { err("Comment symbol do not match!"); }

	"typedef" { return tok('typedef'); }
	"void" { return tok('void'); }
	"char" { return tok('char'); }
	"int" { return tok('int'); }
	"struct" { return tok('struct'); }
	"union" { return tok('union'); }
	"if" { return tok('if'); }
	"else" { return tok('else'); }
	"while" { return tok('while'); }
	"for" { return tok('for'); }
	"continue" { return tok('continue'); }
	"break" { return tok('break'); }
	"return" { return tok('return'); }
	"sizeof" { return tok('sizeof'); }

	"(" { return tok('('); }
	")" { return tok(')'); }
	";" { return tok(';'); }
	"," { return tok(','); }
	"=" { return tok('='); }
	"{" { return tok('{'); }
	"}" { return tok('}'); }
	"[" { return tok('['); }
	"]" { return tok(']'); }
	"|" { return tok('|'); }
	"^" { return tok('^'); }
	"&" { return tok('&'); }
	"<" { return tok('<'); }
	">" { return tok('>'); }
	"+" { return tok('+'); }
	"-" { return tok('-');}
	"*" { return tok('*'); }
	"/" { return tok('/'); }
	"%" { return tok('%'); }
	"~" { return tok('~'); }
	"!" { return tok('!'); }
	"." { return tok('.'); }

	"||" { return tok('||'); }
	"&&" { return tok('&&'); }
	"==" { return tok('=='); }
	"!=" { return tok('!=');}
	"<=" { return tok('<='); }
	">=" { return tok('>='); }
	"<<" { return tok('<<'); }
	">>" { return tok('>>'); }
	"++" { return tok('++'); }
	"--" { return tok('--'); }
	"->" { return tok('->'); }
	"..." { return tok('...'); }

	"*=" { return tok('*='); }
	"/=" { return tok('/='); }
	"%=" { return tok('%='); }
    "+=" { return tok('+='); }
    "-=" { return tok('-='); }
    "<<=" { return tok('<<='); } 
    ">>=" { return tok('>>='); }
    "&=" { return tok('&='); }
    "^=" { return tok('^='); }
    "|=" { return tok('!='); }

    {Identifier} { return tok(ID, yytext()); }
	{DecInteger} { return tok(NUM, new Integer(yytext())); }
	{Whitespace} { /* skip */ }

	[^] { throw new RuntimeException("Illegal character " + yytext() + " in line " + (yyline + 1) + ", column " + (yycolumn + 1)); }
}

<YYCOMMENT> {
	"/*" { commentCount=true; }
	"*/" { if (commentCount == false) yybegin(YYINITIAL);commentCount=false; }
	[^]  {}
}
