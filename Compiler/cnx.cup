package appetizer.syntactic;

import java.io.InputStream;

action code {:
  static appetizer.symbol.Symbol symbol{String s} {
    return appetizer.symbol.Symbol.symbol{s};
  }
:};

parser code {:
  public void report_error{String message, Object info} {
    StringBuffer m = new StringBuffer{"\tParsing error"};
    if {info instanceof java_cup.runtime.Symbol} {
      java_cup.runtime.Symbol s = {java_cup.runtime.Symbol} info;

      if {s.left >= 0} {
        m.append{" in line " + {s.left +1 }};
        if {s.right >= 0} {
          m.append{", column " + {s.right + 1}};
        }
      }
    }
    m.append{" : " + message};
    System.err.println{m};
  }

  public Parser{InputStream inp} {
    this{new Yylex{inp}};
  }
:};

terminal      TYPEDEF,VOID,CHAR,INT,STRUCT,UNION,IF,ELSE,WHILE,FOR,CONTINUE,BREAK,RETURN,SIZEOF;
terminal      LPAREN,RPAREN,SEMICOLON,COMMA,ASSIGN,LBRACE,RBRACE,LBRACK,RBRACK,BITOR,INDEX,BITAND,LT,GT,PLUS,MINUS,ASTER,DIVIDE,MOD,BITNOT,NOT,DOT;
terminal      OR,AND,EQ,NE,LE,GE,SHL,SHR,INC,DEC,PTR,ELLIPSIS;
terminal      MULASS,DIVASS,MODASS,ADDASS,SUBASS,SHLASS,SHRASS,ANDASS,XORASS,ORASS;
terminal      STR,CHR,NUM,ID;

non terminal cnx1,cnx2,cnx3,cnx4,cnx5,cnx6,cnx7,cnx8,cnx9,cnx10,cnx11,cnx12,cnx13,cnx14,cnx15,cnx16,cnx17,cnx18,cnx19,cnx20,cnx21,cnx22;
non terminal program,declaration,declarator,function_definition,parameters,declarators,init_declarators,init_declarator,initializer,type_specifier,struct_or_union,plain_declaration,plain_declarator,statement,expression_statement,compound_statement,selection_statement,iteration_statement,jump_statement,expression,assignment_operator,assignment_expression,constant_expression,logical_or_expression,logical_and_expression,inclusive_or_expression,exclusive_or_expression,and_expression,equality_expression,equality_operator,relational_expression,relational_operator,shift_expression,shift_operator,additive_expression,additive_operator,multiplicative_expression,multiplicative_operator,cast_expression,type_name,unary_expression,unary_operator,postfix_expression,postfix,arguments,primary_expression,constant;

precedence left COMMA;
precedence right ASSIGN,MULASS,DIVASS,MODASS,ADDASS,SUBASS,SHLASS,SHRASS,ANDASS,ORASS,XORASS;
precedence left OR;
precedence left AND;
precedence left BITOR;
precedence left INDEX;
precedence left EQ,NE;
precedence left LT,LE,GE,GT;
precedence left SHL,SHR;
precedence left DIVIDE,MOD;
precedence right SIZEOF,BITNOT;

start with program;

 program::= cnx22 | cnx22 program;

 cnx22::= declaration | function_definition;
 
 declaration::= TYPEDEF type_specifier declarators SEMICOLON
            | type_specifier init_declarators SEMICOLON
            | type_specifier SEMICOLON
            ;
 
 function_definition::= type_specifier plain_declarator LPAREN parameters RPAREN compound_statement
                    | type_specifier plain_declarator LPAREN RPAREN compound_statement;
 
 parameters::= plain_declaration cnx1 COMMA ELLIPSIS
           | plain_declaration COMMA plain_declaration
           | plain_declaration;

 cnx1::= COMMA plain_declaration| cnx1 COMMA plain_declaration;
 
 declarators::= declarator cnx2
            | declarator;

 cnx2::= COMMA declarator | cnx2 COMMA declarator;
 
 init_declarators::= init_declarator cnx3
                 | init_declarator
                 ;

 cnx3::= COMMA init_declarator | cnx3 COMMA init_declarator;
 
 init_declarator::= declarator ASSIGN initializer
                | declarator;
 
 initializer::= assignment_expression
            | LBRACE cnx16 RBRACE
            ;

 cnx16::=initializer| cnx16 initializer;
 
 type_specifier::= VOID | CHAR | INT | ID
               | struct_or_union ID LBRACE cnx17 RBRACE
               | struct_or_union LBRACE cnx17 RBRACE
               | struct_or_union ID
               ;

 cnx17::=plain_declaration| cnx17 plain_declaration;
 
 struct_or_union::= STRUCT | UNION;
 
 plain_declaration::= type_specifier cnx18;

 cnx18::=declarator|declarator cnx18;
 
 declarator::= plain_declarator LPAREN parameters RPAREN
           | plain_declarator LPAREN RPAREN
           | plain_declarator cnx4
           | plain_declarator
           ;

 cnx4 ::= LBRACK constant_expression RBRACK | LBRACK constant_expression RBRACK cnx4;
 
 plain_declarator::= cnx20 ID
                 | ID
                 ;

 statement::= expression_statement
          | compound_statement
          | selection_statement
          | iteration_statement
          | jump_statement
          ;
 
 expression_statement::= expression SEMICOLON
                     | SEMICOLON;
 
 compound_statement::= LBRACE cnx18 cnx21 RBRACE
                   | LBRACE cnx21 RBRACE
                   | LBRACE cnx18 RBRACE
                   | LBRACE RBRACE;

 cnx21::=statement|statement cnx21;
 
 selection_statement::= IF LPAREN expression RPAREN statement ELSE statement
                    | IF LPAREN expression RPAREN statement
                    ;
 
 iteration_statement::= WHILE LPAREN expression RPAREN statement
                    | FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement
                    | FOR LPAREN expression SEMICOLON expression SEMICOLON  RPAREN statement
                    | FOR LPAREN expression SEMICOLON  SEMICOLON expression RPAREN statement
                    | FOR LPAREN expression SEMICOLON  SEMICOLON  RPAREN statement
                    | FOR LPAREN  SEMICOLON expression SEMICOLON expression RPAREN statement
                    | FOR LPAREN  SEMICOLON expression SEMICOLON  RPAREN statement
                    | FOR LPAREN  SEMICOLON  SEMICOLON expression RPAREN statement
                    | FOR LPAREN  SEMICOLON  SEMICOLON  RPAREN statement
                    ;
 
 jump_statement::= CONTINUE SEMICOLON
               | BREAK SEMICOLON
               | RETURN expression SEMICOLON
               | RETURN SEMICOLON
               ;

 expression::= assignment_expression cnx5
           | assignment_expression;

 cnx5::= COMMA assignment_expression | COMMA assignment_expression cnx5;
 
 assignment_expression::= logical_or_expression
                      | unary_expression assignment_operator assignment_expression
                      ;
 
 assignment_operator::= ASSIGN | MULASS | DIVASS | MODASS | ADDASS | SUBASS | SHLASS | SHRASS | ANDASS | XORASS | ORASS;
 
 constant_expression::= logical_or_expression;
 
 logical_or_expression::= logical_and_expression cnx6
                      | logical_and_expression;

 cnx6::=OR logical_and_expression | OR logical_and_expression cnx6;
 
 logical_and_expression::= inclusive_or_expression cnx7
                       | inclusive_or_expression;
 
 cnx7::=AND inclusive_or_expression | AND inclusive_or_expression cnx7;

 inclusive_or_expression::= exclusive_or_expression cnx8
                        | exclusive_or_expression;

 cnx8::=BITOR exclusive_or_expression | BITOR exclusive_or_expression cnx8;
 
 exclusive_or_expression::= and_expression cnx9
                        | and_expression;

 cnx9::=INDEX and_expression | INDEX and_expression cnx9;
 
 and_expression::= equality_expression cnx10
               | equality_expression;

 cnx10::=BITAND equality_expression | BITAND equality_expression cnx10;
 
 equality_expression::= relational_expression cnx11
                    | relational_expression;

 cnx11::=equality_operator relational_expression | equality_operator relational_expression cnx11;
 
 equality_operator::= EQ | NE;
 
 relational_expression::= shift_expression cnx12
                      | shift_expression;

 cnx12::=relational_operator shift_expression | relational_operator shift_expression cnx12;
 
 relational_operator::= LT | GT | LE | GE;
 
 shift_expression::= additive_expression cnx13
                 | additive_expression;

 cnx13::=shift_operator additive_expression | shift_operator additive_expression cnx13;
 
 shift_operator::= SHL | SHR;
 
 additive_expression::= multiplicative_expression cnx14
                    | multiplicative_expression;

 cnx14::=additive_operator multiplicative_expression | additive_operator multiplicative_expression cnx14;
 
 additive_operator::= PLUS | MINUS;
 
 multiplicative_expression::= cast_expression cnx15
                          | cast_expression;

 cnx15::=multiplicative_operator cast_expression| multiplicative_operator cast_expression cnx15;
 
 multiplicative_operator::= ASTER | DIVIDE | MOD;
 
 cast_expression::= unary_expression
                | LPAREN type_name RPAREN cast_expression
                ;
 
 type_name::= type_specifier cnx20
          | type_specifier;

 cnx20::=ASTER| ASTER cnx20;
 
 unary_expression::= postfix_expression
                 | INC unary_expression
                 | DEC unary_expression
                 | unary_operator cast_expression
                 | SIZEOF unary_expression
                 | SIZEOF LPAREN type_name RPAREN
                 ;
 
 unary_operator::= BITAND | ASTER | PLUS | MINUS | BITNOT | NOT;
 
 postfix_expression::= primary_expression cnx19
                   | primary_expression;

 cnx19::= postfix | postfix cnx19;
 
 postfix::= LBRACK expression RBRACK
        | LPAREN arguments RPAREN
        | DOT ID
        | PTR ID
        | INC
        | DEC
        ;
 
 arguments::= assignment_expression cnx5
          | assignment_expression
          ;
 
 primary_expression::= ID
                   | constant
                   | STR
                   | LPAREN expression RPAREN
                   ;
 
 constant::= NUM
         | CHR
         ;
